//------------------------------------------------------------------------------------
// Gnx_Mission1.c
//------------------------------------------------------------------------------------

#include    "Gnx_Param.h"
#include    <math.h>     // Pour les calculs de log10 (dB), ceil() et pow()
#include    <stdlib.h>   // Pour la fonction de tri (qsort)

extern const char Gnn_myLogo[];


#define ETAT_APPUYE LOW
float voltage; 
float temperature;

#define PORT_LED_R PF_1
#define PORT_LED_B PF_2
#define PORT_LED_G PF_3
#define  VCC_MILLIV     3300 /* en entier  */

#define  VCC_VOLTS      3.3     /* en flotant */

#define  NUM_MAX        4096    


// --- PUSH BUTTON ---
#define buttonPin PC_6      


// --- CAPTEUR TEMPÉRATURE (LM35) ---
#define TEMPERATURE_PIN PD_1    

// --- CAPTEUR SONORE (MICROPHONE) ---
#define SOUND_SENSOR_PIN PD_3     

// --- PARAMÈTRES CAPTEUR SONORE ---
#define SAMPLE_WINDOW_MS 50       
#define NUM_SAMPLES_BUFFER 10

int etatBouton; 
int tensionport; 
float tension; 

int tensionPotentiometre;
const int Taille_Tableau = 5000;//valeur a modifier pour modifier la taille du tableau des pics de tensions mesuré par le micro    
 
float tensionP; 


void setup()
//----------------------------------------------------
//----------------------------------------------------
{
    Serial.begin(9600);
    Serial1.begin(9600);
    
    pinMode(PORT_LED_R, OUTPUT);
    pinMode(PORT_LED_G, OUTPUT);
    pinMode(PORT_LED_B, OUTPUT);
    
    // Allume la LED en rouge pour signaler le début de l'initialisation
    digitalWrite(PORT_LED_R, HIGH);
    digitalWrite(PORT_LED_B, LOW);
    digitalWrite(PORT_LED_G, LOW);

    Serial.println("+++ INIT AOLED  Debut  ++++");
    AOLED_InitScreen();
    Serial.println("+++ INIT AOLED Fin    ++++");
    delay(2000);

    // Completer le tableau Gnn_myLogo[] pour afficher votre Logo
    AOLED_DisplayImage((char*)Gnn_myLogo);

    digitalWrite(PORT_LED_R, LOW);
    digitalWrite(PORT_LED_G, HIGH);
    delay(1000);

    // --- Configuration Bluetooth ---
    Serial.println("AT_NAME=G07C");  // visualiser sur la console pour verification
    Serial1.print( "AT_NAME=G07C");

    // --- Configuration du bouton ---
    pinMode(buttonPin, INPUT_PULLUP);   

    Serial.println("\nSysteme pret. Appuyez sur le bouton pour une mesure sonore.");

}

// définitions des fonctions utilisé par la suite
void  Test_Affi_Oled(void);
void  Test_BlueTooth(void);
void  Test_LedTricolore(void);
float Test_Potentiometre(void);
short Test_BoutonPoussoir(void);
void  Test_Temperature(void);
void  FaireUneMesureSonore();

// Fonction utilitaire pour qsort
int compare_float(const void *a, const void *b) {
    float fa = *(const float*)a;
    float fb = *(const float*)b;
    if (fa < fb) return -1;
    if (fa > fb) return 1;
    return 0;
}


void loop()
{
    // loop juste pour le capteur sonor
    static int lastButtonState = HIGH; 
    
    int currentButtonState = digitalRead(buttonPin);
    if (currentButtonState == ETAT_APPUYE && lastButtonState != ETAT_APPUYE) 
    {
        // On allume la LED en bleu pendant la mesure
        digitalWrite(PORT_LED_B, HIGH);
        digitalWrite(PORT_LED_G, LOW); // Eteint la verte

        FaireUneMesureSonore(); // On lance la salve de mesure
        
        digitalWrite(PORT_LED_B, LOW); // On éteint la bleue
        digitalWrite(PORT_LED_G, HIGH); // On rallume la verte (prêt)
    }

    lastButtonState = currentButtonState; // On sauvegarde l'état actuel pour le prochain tour
    
    delay(20); 
}
/*
//----------------------------------------------------
// FONCTION AFFICHEUR OLED
//----------------------------------------------------
void    Test_Affi_Oled(void)
{
    short  count, dizaine, unite;       
    char  Bufftexte[10];

    Serial.println(" ");
    Serial.println("      --- test de l'afficheur OLED  ");
    AOLED_DisplayImage((char*)Gnn_myLogo);
    count = 21;    
    while (1) {
        dizaine = count / 10;  
        unite = count % 10;   
        Bufftexte[0] = dizaine + 0x30;  
        Bufftexte[1] = unite + 0x30;   
        Bufftexte[2] = 0;            
        AOLED_DisplayImage((char*)Gnn_myLogo);
        Serial.print(" ");      
        Serial.println(Bufftexte);
        count = count + 1;
        if (count >= 41)
            count = 21;     
        delay(1000);
    }
}
*/

/*
//----------------------------------------------------
// FONCTION LED RGB
//----------------------------------------------------
void  Test_LedTricolore(void)
{

    digitalWrite(PORT_LED_R, LOW);
    digitalWrite(PORT_LED_B, LOW);
    digitalWrite(PORT_LED_G, LOW);
    delay(1000);
    digitalWrite(PORT_LED_R, HIGH);
    digitalWrite(PORT_LED_B, LOW);
    digitalWrite(PORT_LED_G, LOW);
    delay(1000);
    digitalWrite(PORT_LED_R, LOW);
    digitalWrite(PORT_LED_B, HIGH);
    digitalWrite(PORT_LED_G, LOW);
    delay(1000);
    digitalWrite(PORT_LED_R, HIGH);
    digitalWrite(PORT_LED_B, HIGH);
    digitalWrite(PORT_LED_G, LOW);
    delay(1000);
    digitalWrite(PORT_LED_R, LOW);
    digitalWrite(PORT_LED_B, LOW);
    digitalWrite(PORT_LED_G, HIGH);
    delay(1000);
    digitalWrite(PORT_LED_R, HIGH);
    digitalWrite(PORT_LED_B, LOW);
    digitalWrite(PORT_LED_G, HIGH);
    delay(1000);
    digitalWrite(PORT_LED_R, LOW);
    digitalWrite(PORT_LED_B, HIGH);
    digitalWrite(PORT_LED_G, HIGH);
    delay(1000);
    digitalWrite(PORT_LED_R, HIGH);
    digitalWrite(PORT_LED_B, HIGH);
    digitalWrite(PORT_LED_G, HIGH);
    delay(1000);
    
}
*/
/*
//----------------------------------------------------
// FONCTION TEMPÉRATURE 
//----------------------------------------------------
void Test_Temperature(void)
{
    int valeur_numerique_lue = analogRead(TEMPERATURE_PIN); 

    float tension_volts = (valeur_numerique_lue * 3.3) / 4095.0;

    float temperature = tension_volts * 100.0;

    Serial.print("Valeur numérique lue = ");
    Serial.print(valeur_numerique_lue);
    Serial.print(" / Temperature = ");
    Serial.print(temperature, 1); 
    Serial.println(" °C");
}

*/
/*
//----------------------------------------------------
// FONCTION POTENTIOMETRE
//----------------------------------------------------
float Test_Potentiometre(void)
{
    int tensionPotentiometre = analogRead(PORT_POTAR); 
    float tensionP = (tensionPotentiometre * VCC_VOLTS ) / NUM_MAX; 
    Serial.print("Valeur numérique lue = ");
    Serial.print(tensionPotentiometre);
    Serial.print(" / Tension correspondante = ");     
    Serial.print(tensionP);
    Serial.print(" voltes");
    Serial.println();
    return tensionP;
}
*/
/*
//----------------------------------------------------
// FONCTION BLUETOOTH
//----------------------------------------------------
void  Test_BlueTooth(void)
{
    
    if (Test_BoutonPoussoir() == ETAT_APPUYE)  {
        Serial1.println("Bouton appuye");
        
    }
    else {
        Serial1.println("low");
    }

    
    while (Serial1.available() > 0) { 
        char messageRecue = Serial1.read(); 
        Serial.println(messageRecue);
    }
    delay(1000);
}
*/
/*
//----------------------------------------------------
// FONCTION BOUTON POUSSOIR
//----------------------------------------------------
short Test_BoutonPoussoir(void)
{
    etatBouton = digitalRead(buttonPin); 
    
    int tensionport = analogRead(buttonTension); 
    float tension = (tensionport * VCC_VOLTS ) / NUM_MAX; 

    if (etatBouton == ETAT_APPUYE) {    
        Serial.print("Valeur lue =");
        Serial.print(tensionport);
        Serial.print(" / Etat du bouton = Appuye");
    } 
    else {
        Serial.print("Valeur lue =");
        Serial.print(tensionport);
        Serial.print(" / Etat du bouton = Pas Appuye");
    }

    Serial.println();     // terminer par un retour ligne

    return etatBouton;
}
*/

//-----------------------------------------------------------------------------
//  OLedAffi_MyLogo.h
//-----------------------------------------------------------------------------

const char Gnn_myLogo[128*8] = { // code hexa des pixel de 'ecran ( a ce que j'en ai compris )
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xe0, 0xf8, 0x7c, 0x0c, 0x00, 0x00, 0xc0, 0xf0, 0xfc, 
0x1c, 0x00, 0x00, 0xc0, 0xf0, 0xf8, 0x3c, 0x00, 0x00, 0x00, 0x80, 0xe0, 0xf8, 0x7c, 0x3c, 0x3c, 
0xf8, 0xf0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xf0, 0xfc, 0x3c, 0x0c, 0x00, 0x80, 0xe0, 
0xf8, 0x7c, 0x1c, 0x00, 0x00, 0x00, 0x80, 0xe0, 0xf8, 0x7c, 0x1c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 
0x00, 0x00, 0x00, 0x00, 0x80, 0xe0, 0xf8, 0xfc, 0x1f, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xf0, 0xf8, 0x3c, 0x00, 0x00, 0x00, 
0xc0, 0xf0, 0xf8, 0xfc, 0xf8, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xf8, 0x7c, 0x1c, 0x00, 0x00, 0x00, 
0xc0, 0xe0, 0xf8, 0x7c, 0x1c, 0x80, 0xf0, 0xf8, 0x7c, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x10, 0xfe, 0xff, 0x87, 0x81, 0xc0, 0xf0, 0xfc, 0xff, 0x0f, 0x03, 0x80, 
0xf0, 0xf8, 0x7f, 0x0f, 0x03, 0x00, 0x80, 0xe0, 0xf0, 0xfe, 0x3f, 0x3f, 0x3f, 0xf8, 0xf8, 0xf8, 
0xff, 0x1f, 0x07, 0x00, 0x00, 0x00, 0x3c, 0xff, 0xff, 0x83, 0x80, 0xe0, 0xf8, 0x7e, 0x1f, 0x07, 
0x01, 0x00, 0x80, 0xe0, 0xf8, 0xfe, 0x3f, 0x1f, 0x1f, 0x0c, 0x08, 0x08, 0x00, 0x00, 0x00, 0x80, 
0xc0, 0xf0, 0xfc, 0xff, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xf0, 0xfc, 0x3f, 0x0f, 0x03, 0x00, 0xc0, 0xf0, 0xfc, 0x7f, 
0x0f, 0x0f, 0x1f, 0xff, 0xff, 0xfc, 0xf8, 0xfc, 0x3f, 0x0f, 0x01, 0x00, 0x80, 0xe0, 0xf8, 0xfe, 
0xff, 0xff, 0xfb, 0xfc, 0x7f, 0x1f, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x0f, 0x0f, 0x0f, 0x07, 0x07, 0x07, 0x0f, 0x0f, 0x0f, 
0x07, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x0f, 0x07, 0x03, 0x00, 0x00, 0x00, 0x0c, 0x0f, 0x07, 0x03, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x0f, 0x0f, 0x07, 0x03, 0x00, 0x00, 0x00, 
0x00, 0x0c, 0x0f, 0x0f, 0x0f, 0x0e, 0x0c, 0x0c, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xf8, 0xfe, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0x70, 0x20, 0x00, 
0x00, 0x00, 0x00, 0x0c, 0x0f, 0x0f, 0x07, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x0f, 0x07, 0x01, 0x00, 
0x00, 0x00, 0x00, 0x0f, 0x0f, 0x0f, 0x03, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x0f, 0x07, 0x01, 0x00, 
0x01, 0x03, 0x0f, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 
0x3c, 0x3c, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0x7c, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0xe0, 0xfc, 0xff, 0xff, 0x7f, 0x3f, 0x0f, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xfe, 
0x3f, 0x1f, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x03, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};



//----------------------------------------------------
// FONCTION CAPTEUR SONORE 
//----------------------------------------------------
void FaireUneMesureSonore()
{
    Serial.println("---------------------------------");
    Serial.print("Lancement d'une salve de ");
    Serial.print(Taille_Tableau);
    Serial.println(" mesures...");
    
    // "Vider le tableau" = On crée un tableau local neuf
    int sample_buffer[Taille_Tableau];
    int sample_buffer2[Taille_Tableau];
    int sample;
    
    for(int i = 0; i < Taille_Tableau; i++){
      sample_buffer[i] = analogRead(SOUND_SENSOR_PIN);
      //Serial.println(sample_buffer[i]);
    }
    
    
    
    Serial.println("Fin de la salve ");
    for(int j = 0 ; j < 2 ; j++){
      for(int i = 0; i < Taille_Tableau; i++){
        Serial.println(sample_buffer[i]);
      }
    }
    /*
    for(int i = 0; i < Taille_Tableau; i++){
      sample_buffer2[i] = analogRead(SOUND_SENSOR_PIN);
      //Serial.println(sample_buffer[i]);
    }
    for(int i = 0; i < Taille_Tableau; i++){
      Serial.println(sample_buffer2[i]);
    }
    */
 
    
      
    
    
    
    /*
    // Remplir le tableau (mode "bloquant") ---
    for (int i = 0; i < NUM_SAMPLES_BUFFER; i++)
    {
        // On prend UNE mesure d'amplitude pic-à-pic
        unsigned long startTime = millis();
        
        int sampleMin = 4095;
        int sampleMax = 0;

        while (millis() - startTime < SAMPLE_WINDOW_MS)
        {
            sample = analogRead(SOUND_SENSOR_PIN); // Utilise PD_0
            if (sample < 4096) 
            {
                if (sample > sampleMax) { sampleMax = sample; }
                if (sample < sampleMin) { sampleMin = sample; }
            }
        }
        float peakToPeak = sampleMax - sampleMin;
        
        // On stocke la mesure dans le tableau
        sample_buffer[i] = peakToPeak;
    }

    Serial.println("Salve terminee. Calcul de la moyenne...");

    // Calculer le 'trim_count' dynamique (VOTRE LOGIQUE) ---
    int trim_count = (int)ceil((float)NUM_SAMPLES_BUFFER / 4.0);

    // ---Faire la "Moyenne Tronquée" ---

    // Copier le tampon
    float sorted_buffer[NUM_SAMPLES_BUFFER];
    for (int i = 0; i < NUM_SAMPLES_BUFFER; i++) {
        sorted_buffer[i] = sample_buffer[i];
    }

    // Trier le tableau
    qsort(sorted_buffer, NUM_SAMPLES_BUFFER, sizeof(float), compare_float);

    //Calculer le nombre d'éléments pour la moyenne
    int itemsToAverage = NUM_SAMPLES_BUFFER - (2 * trim_count);
    float average_amplitude = 0; 

    // Vérification
    if (itemsToAverage <= 0) 
    {
        Serial.println("Erreur: trim_count trop grand! Moyenne simple effectuee.");
        float sum = 0;
        for (int i = 0; i < NUM_SAMPLES_BUFFER; i++) {
            sum += sorted_buffer[i];
        }
        if (NUM_SAMPLES_BUFFER > 0) {
             average_amplitude = sum / NUM_SAMPLES_BUFFER;
        }
    } 
    else 
    {
        //ok : Faire la somme en "ignorant" les extrêmes
        float sum = 0;
        for (int i = trim_count; i < NUM_SAMPLES_BUFFER - trim_count; i++)
        {
            sum += sorted_buffer[i];
        }
        average_amplitude = sum / itemsToAverage;
    }

    // --- Calculs dB et W/m^2 ---
    
    // Calcul de base (relatif à l'ADC)
    float relative_db = 20 * log10(average_amplitude + 1.0); // +1.0 pour éviter log(0)
    
    
    float db_spl_estime = relative_db + 30.0;
    float intensity_W_m2 = pow(10.0, -12.0) * pow(10.0, db_spl_estime / 10.0);


    // --- Étape 5 : Afficher les résultats ---
    Serial.println("\n--- Resultat de la Mesure ---");
    Serial.print("Amplitude Moyenne (0-4095): ");
    Serial.println(average_amplitude, 1); 
    
    Serial.print("Niveau Sonore (estime): ");
    Serial.print(relative_db, 1);
    Serial.println(" dB SPL");
    
    Serial.print("Intensite Sonore (estimee): ");
    Serial.print(intensity_W_m2, 12); // Afficher avec 12 décimales
    Serial.println(" W/m^2");
    Serial.println("---------------------------------");
    */
}

// for i = 0 -> 10000, valeur lue -> tableau, serial print le tableau 
// tableau(raw : 0 - 4096 sans traitement)  -> csv 
